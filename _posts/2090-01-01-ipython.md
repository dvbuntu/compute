---
layout: post
title: IPython
cover: none.png
date:   2090-01-01 12:00:00
categories: posts
---

`python` is an easy-to-learn programming language that is often fast enough for computing purposes.  `ipython` is a helpful interactive environment in which to run `python` code.  There are [numerous](http://showmedo.com/videotutorials/series?name=CnluURUTV) [guides](https://ipython.org/ipython-doc/3/interactive/tutorial.html) [online](https://damontallen.github.io/IPython-quick-ref-sheets/) for learning how to use `ipython`.  But there's a few tips that help you bootstrap yourself into an expert.

Getting Help
---

`foo?` will show you the docstring for the object `foo`.  This can be a class, function, instance, or pretty much anything.  This works on built-ins, modules, and anything you define in the local interpreter.  It reports some basic information (type, arguments, etc) always, but to see the docstring of course requires there to be an actual docstring.  For a function, this is the triple-quoted string that occurs immediately after the `def` line.

```python
[2]> bin?
Type:        builtin_function_or_method
String form: <built-in function bin>
Namespace:   Python builtin
Docstring:
bin(number) -> string

Return the binary representation of an integer.

   >>> bin(2796202)
   '0b1010101010101010101010'

[3]> int?
Type:            type
String form:     <class 'int'>
Namespace:       Python builtin
Init definition: int(self, *args, **kwargs)
Docstring:
int(x=0) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
```

`foo??` takes this one step further.  Sometimes the docstring isn't enough; you need to peek inside the python source code for a function to see what it's literally doing.  For functions, classes, methods, etc, `foo??` will show you the actual source code for that object.  Note that especially for built-ins, many functions are defined in C rather than python.  For these, you won't see any additional code.  Intermediate wrappers like SWIG will often show you the wrapping code, which isn't very helpful.

```python
# Looks like a simple docstring
[19]> foo?
Type:        function
String form: <function foo at 0x7f06c1ab3d90>
File:        /home/user/<ipython-input-18-9b3437de933e>
Definition:  foo()
Docstring:   Return 4.0
      
# A little dishonest
[22]> foo??
Type:        function
String form: <function foo at 0x7f06c1ab3d90>
File:        /home/user/<ipython-input-18-9b3437de933e>
Definition:  foo()
Source:
def foo():
    '''Return 4.0'''
    return 3.9999999
```

`foo.[tab]` or `dir(foo)` is another critical learning tool.  It tells you what methods and attributes come with `foo`.  For new classes or objects, this is a great way to glance at what features or functions are already available.  Often, you know a library has some feature, and this will tell you how its named.  If you're used to GUIs, this is like looking through the menu to see what buttons you can click.  Note that `dir(foo)` will show you so-called "private" methods, those that begin with `__` (two underscores, or "dunder" in python parlance).  I typically stick with tab completion as the private methods often only clutter the view.

```python
[36]> a = 4
[37]> a.
a.bit_length   a.denominator  a.imag         a.real         
a.conjugate    a.from_bytes   a.numerator    a.to_bytes     
[37]> dir(a)
 #    
['__abs__',
 '__add__',
 '__and__',
...
```

Of course, you'll find yourself needing to combine these learning tools!  Tab complete may reveal some interesting methods, then you can look at what they are using the question marks.  Or the docstring points to another class, and you then run `dir` on it to reveal how to access it.

Having these key techniques ready at your fingertips is amazingly efficient.  They don't tell you everything, but they do let you quickly scan through your options, learn new methods, and see exactly what's occurring.  This is all within the interpreter and totally textual.  No browser, graphics, or network connection required.  Just instant feedback.

numpy
---

`numpy` is a suite of Python libraries for doing numerical computations (especially with arrays).  An array is like a list, but specific to one data type.  In a traditional Python list, you can put arbitrary objects into a list, ex.

```python
[38]> foo = [4, 'abc', math.sin]
```

While the generality of a list is very convenient, the price is that manipulating lists is expensive.  Every time you do an operation, Python has to check what type of object is in that position.  This also makes storing and accessing lists expensive.

`numpy` solves this problem by making arrays like `C` or `fortran` arrays.  That is, they are really just chunks of memory with a specfic data type.  This means that they are fast, memory efficient, and can quickly be manipulated.  `numpy` takes advantage of this, offering a fully-featured linear algebra library (implemented in a compiled language) to do computations on big arrays.  It makes it easy to do large computations.

```python
[39]> # It's easy to specify multidimensional arrays!
[40]> a = np.zeros([2,3,4])
[41]> a
array([[[ 0., 0., 0., 0.],
        [ 0., 0., 0., 0.],
        [ 0., 0., 0., 0.],

       [[ 0., 0., 0., 0.],
        [ 0., 0., 0., 0.],
        [ 0., 0., 0., 0.]]])
```

`numpy` has built-in convenient default behavior with matrices.  You can do things like add scalars to all elements, do an element-wise multiply with two matrices, and of course matrix multiplication.

```python
[42]> # add a scalar to a matrix
[43]> a = np.zeros([2,3,4])
[44]> a += 5
[45]> a
array([[[ 5.,  5.,  5.,  5.],
        [ 5.,  5.,  5.,  5.],
        [ 5.,  5.,  5.,  5.]],

       [[ 5.,  5.,  5.,  5.],
       [ 5.,  5.,  5.,  5.],
       [ 5.,  5.,  5.,  5.]]])

[46]> # element-wise multiplication
[47]> b = np.array([[1,2],[3,4]])
[48]> c = np.array([[6,7],[8,9]])
[49]> b*c
array([[ 6, 14],
       [24, 36]])

[50]> # matrix multiplication
[51]> np.dot(b,c)
array([[22, 25],
       [50, 57]])
```

pylab
---

Knowing how to get help and do fast numeric computations is wonderful, but interactive computing really shines when you can *plot* data in revealing ways.  `pylab` is one module that allows for simple interactive plotting.  Let's try plotting a few points:

```python
[52]> # specify the modules
[53]> import pylab as pl
[54]> import numpy as np

[55]> # make some random data
[56]> a = np.random.rand(10,5)

[57]> # make plots show up when we call them
[58]> pl.ion()

[59]> # Plot the first row as a line, value vs index
[60]> pl.plot(a[0])

[61]> # How about red circles instead?
[62]> pl.plot(a[1],'ro')

[63]> # Get some more information
[64]> pl.plot? # super helpful
```

![Figure. Simple line and scatter plot]({{ site.baseurl }}/images/ipython_plot1.png)

`pylab` has lots of great plotting routines, but I want to highlight one more thing in addition to the scatter plot.  `pylab` can also create heat maps.  That is, imagine you have a 2D array; now color each cell based on its value.  Higher values might be more red and smaller values might be more blue.  This is often an excellent way to compare several rows of data or sense overall patterns.  I use heat maps almost every time I open Python.

```python
[65]> # Try this one simple command to make heat maps.  Fools hate it
[66]> pl.pcolor(a)

[67]> # Of course, lots of helpful options
[68]> pl.pcolor?
```

![Figure. Heat plot]({{ site.baseurl }}/images/ipython_plot2.png)

These are the key Python tools for doing effective data analysis.  You will surely find more specific ones as you get into projects, but I've found these basics to be remarkably applicable and resilient.  As a core foundation, it's hard to beat.

Alternative Interface
---

You can now use IPython through a web-based notebook interface.  Here's my take on [Jupyter]({{ site.baseurl }}{% post_url 2040-01-01-jupyter %}).
