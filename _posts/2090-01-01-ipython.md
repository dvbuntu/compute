---
layout: post
title: IPython
cover: none.png
date:   2090-01-01 12:00:00
categories: posts
---

Ipython
---

`python` is an easy-to-learn programming language that is often fast enough for computing purposes.  `ipython` is a helpful interactive environment in which to run `python` code.  There are [numerous]() [guides]() [online]() for learning how to use `ipython`.  But there's a few tips that help you bootstrap yourself into an expert.

Getting Help
---

`foo?` will show you the docstring for the object `foo`.  This can be a class, function, instance, or pretty much anything.  This works on built-ins, modules, and anything you define in the local interpreter.  It reports some basic information (type, arguments, etc) always, but the docstring of course requires there to be some actual docstring.  For a function, this is the triple-quoted string that occurs immediately after the `def` line.

```python
>>> bin?
[2]> bin?
Type:        builtin_function_or_method
String form: <built-in function bin>
Namespace:   Python builtin
Docstring:
bin(number) -> string

Return the binary representation of an integer.

   >>> bin(2796202)
   '0b1010101010101010101010'

[3]> int?
Type:            type
String form:     <class 'int'>
Namespace:       Python builtin
Init definition: int(self, *args, **kwargs)
Docstring:
int(x=0) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
```

`foo??` takes this one step further.  Sometimes the docstring isn't enough; you need to peek inside the python source code for a function to see what it's literally doing.  For functions, classes, methods, etc, `foo??` will show you the actual source code for that object.  Note that especially for built-ins, many functions are defined in C rather than python.  For these, you won't see any additional code.  Intermediate wrappers like SWIG will often show you the wrapping code, typically not very helpful.

```python
# nothing suspicious about this function
[18]> def foo():
          '''Return 4.0'''
          return 3.9999999

# Looks like a simple docstring
[19]> foo?
Type:        function
String form: <function foo at 0x7f06c1ab3d90>
File:        /home/user/<ipython-input-18-9b3437de933e>
Definition:  foo()
Docstring:   Return 4.0
      
# A little dishonest
[22]> foo??
Type:        function
String form: <function foo at 0x7f06c1ab3d90>
File:        /home/vanboxel/proj/compute/<ipython-input-18-9b3437de933e>
Definition:  foo()
Source:
def foo():
    '''Return 4.0'''
    return 3.9999999
```

`foo.[tab]` or `dir(foo)` is another critical learning tool.  It tells you what methods and attributes come with `foo`.  For new classes or objects, this is a great way to glance at what features or functions are already available.  Often, you know a library has some feature, and this will tell you how its named.  If you're used to GUIs, this is like looking through the menu to see what buttons you can click.  Note that `dir(foo)` will show you so-called "private" methods, those that begin with `__` (two underscores, or "dunder" in python parlance).


