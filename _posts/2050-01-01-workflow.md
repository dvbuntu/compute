---
layout: post
title: Workflow
cover: none.png
date:   2050-01-01 12:00:00
categories: posts
---

Problem
---

Suppose you've got a basic setup for data analysis with `ipython` and `vim` (and hopefully `tmux`).  In the text editor, you compose your commands (enjoying more power and flexibility than in `ipython`), and copy-paste away.  It works pretty well.  But every time, you have to copy paste, it distracts you from the data.  It doesn't seem like much at first, but it adds up.  But it's a toll you pay every time.  And it's a toll you don't have to pay.  So what's your workflow solution for a better REPL?

Workflow Options
---

1. [Pure `ipython`]({{ site.baseurl }}{% post_url 2090-01-01-ipython %}) (or your favorite interpreter)
   Ipython, as noted, is a fantastic interpreter, but not a superb workflow.  The big advantage is that your REPL output is directly below each of your inputs, and you get "instant" feedback when you compute.  While this isn't to be discounted, Ipython doesn't offer support for *organizing* your analysis.  Depending on your `readline()` settings, you do get limited text editing support within the interpreter, but only for a single line generally.  And you can save the input to a session to a text file, but that saves every line.  Unless you never make a mistake, that pollutes your history.  Finally, while the interpreter has some shell shortcuts, it's not a full terminal and so has necessarily limited functionality.  For poking around, Ipython is great, but serious projects demand a more intentional workflow.
2. Vim + `ipython` copy-paste
    Having another terminal running ViM or your favorite text editor to compose code and then running it under IPython (or whatever) addresses some of the problems of the pure interpreter.  You get full text editing control to craft, save, and git commit all your great ideas (leave the bad ones out).  But now you have to transport your code from the text editor to the interpreter for execution.  This physical distance is a *mental distance* between code and execution.  Highlighting the right thing to copy-paste takes time and focus.  And the simple digital task, "execute this code and show me the results", becomes the analog dexterity chore of selecting just the right characters.  It doesn't seem like a big deal, but this will slow you down.
3. Integrated Development Environment (IDE) (compromise)
    IDEs, like Eclipse, are great at what they do.  They;ve been specifically designed to make software development easy to spin up and manage.  Many support plugin frameworks to extend functionality into other domains or toolsets.  Powerful text editing and templating are probably already built-in.  But when you have so many targeted features, it's likely that you've got bloat as well.  Widgets you'll never use are taking up screen real estate, adding noise to the documentation making it harder to learn, and generally getting in the way.  Conversely, the environment make lack features that you really want!  In a shell, you can almost certainly hack in any desired feature, but adding such a thing to an IDE may be challenging.  IDEs may be great for software development, but they're not typically designed for data analysis.
4. Data Analysis GUI package
    All-in-one data analysis packages, like LIMDEP, Matlab, or Rcmdr, are generally pretty good.  Chances are there's one in the domain you're working in, and it's probably open source (or has an open source clone).  These fully integrated toolsets typically allow writing a script in a decent text editing environment and offer one-click execution for the file, displaying graphics to go along with.  They do data analysis, and they are good at it; but flexibility again becomes a problem.  Trying to coerce LIMDEP into doing a `for` is a nitemare.  Languages like R are more programmatic, but limitations are inevitable in a complex project.  The less you have to port to a custom environment, the better.
5. [`ipython` Notebook/Jupyter]({{ site.baseurl }}{% post_url 2040-01-01-jupyter %})
    Jupyter Notebooks are something that I hadn't been impressed with until recently.  Briefly, they allow writing code right next to output just as in a standard IPython interpreter, but they support graphical output as well.  More kernels are being supported all the time, making this almost as flexible as the shell.  And my one gripe, text editing support, has some reasonably effective workarounds.  Enough so that I think it may be a [Worthy Workflow]({{ site.baseurl }}{% post_url 2040-01-01-jupyter %}).

All of these have weaknesses and strengths.  So we're going to build our own using the [tools]({{ site.baseurl }}{% post_url 2090-01-01-ipython %}) [described]({{ site.baseurl }}{% post_url 2080-01-01-tmux %}) [previously]({{ site.baseurl }}{%post_url 2070-01-01-slimux %}) for maximum flexibility when doing interactive data exploration.  Bridge the gap between your editor and your interpreter.  One or two keystrokes is all it takes; your fingers never leave the keyboard and your focus never leaves the problem.

*Improve your REPL; improve your computing effectiveness.
Make the computer compute; you do the fun stuff.*

Getting the Tools
---

To take the easy route, clone my [compute-tools](http://github.com/dvbuntu/compute-tools) repository on a machine running ArchLinux.  From there, you can run `init.sh` to install a basic desktop including the Interactive Computing Workflow once you have a user.  Or, if you already have a desktop environment, you can use `ww.install.sh` to only install the core tools for the workflow.  Adapting these scripts to your local environment shouldn't be too difficult.

Installing things manually, use your [favorite](https://www.archlinux.org) Linux distribution's package manager to install `tmux`, `python3` (or `python2` for that classic feel), and `ipython`.  You're also going to want `numpy` and `pylab` for data analysis and visualization.  If you really like Ruby, you can swap that in for Python for similar effect.

`slimux` may not be available in your distribution repositories, but it's easy to install from source.  The [Github page](https://github.com/epeli/slimux) includes a simple guide.  Essentially, you install a vim plugin, `pathogen`, that allows you to easily install other vim plugins, like `slimux`.

I'm working on prepackaging all of these things.  I've had a virtual machine image, but that's a huge file.  I tried a metapackage in the [AUR](aur4.archlinux.org), but it required more hacks than writing my own script.  In the future, I will simply sell flash drives with a dekstop pre-installed with a 'Live' version of your favorite Linux flavor.  These tools are all open source and readily available, so what's your excuse?

Feel the Power
---

Open up your favorite terminal.  I prefer `xterm` with some improved font and color choices, but feel free to use anything you like.  Now maximize your terminal to avoid wasting any screen real estate (I turn off all window decorations even to get that extra line).  Fire up [`tmux`]({{ site.baseurl }}{% post_url 2080-01-01-tmux %}) and divide your window into a left pane and right pane, as shown below.

![Figure. Simple tmux layout]({{ site.baseurl }}/images/tmux_simple.png)

I like to put my interactive session (usually [`Ipython`]({{ site.baseurl }}{% post_url 2090-01-01-ipython %}) but sometimes R, Ruby, or gdb) on the left and my text editor (`vim` or your favorite [`slimux`]({{ site.baseurl }}{%post_url 2070-01-01-slimux %}) compatible software) on the right.  What's important is that you can see both on the same screen and can jump between them with one command (`tmux select-pane` in this case).

Now, compose your desired interactive commands in your text editor and start sending them to your interactive session using [`slimux`]({{ site.baseurl }}{%post_url 2070-01-01-slimux %}).  I like to write logically cohesive blocks first, but you can be as loose or as tight as you like with how often you send.  The key is that `python` or whatever executes your command and prints output.  Maybe you realized you did something wrong; now you simply change a few characters in your text (with full text editing support!) and re-send the lines.  It's so simple, and so liberating.

Here's a brief video where I'll walk you through some of these steps.  For more advanced lessons, please check out [`training`]({{ site.baseurl }}{%post_url 2030-01-01-training %}).

<iframe width="560" height="315" src="https://www.youtube.com/embed/F9VeY5KFDl8" frameborder="0"> </iframe>
